"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _debug = require("debug");
var BasicParser_1 = require("../common/BasicParser");
var Atom_1 = require("./Atom");
var AtomToken = require("./AtomToken");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var Util_1 = require("../common/Util");
var debug = _debug("music-metadata:parser:MP4");
var Token = require("token-types");
var tagFormat = 'iTunes MP4';
/*
 * Parser for: MPEG-4 Audio / MPEG-4 Part 3 (m4a/mp4) extension.
 * Support for Apple iTunes MP4 tags as found in a M4A/MP4 file.
 * Ref:
 *   http://developer.apple.com/mac/library/documentation/QuickTime/QTFF/Metadata/Metadata.html
 *   http://atomicparsley.sourceforge.net/mpeg-4files.html
 */
var MP4Parser = /** @class */ (function (_super) {
    __extends(MP4Parser, _super);
    function MP4Parser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MP4Parser.read_BE_Signed_Integer = function (value) {
        return Token.readIntBE(value, 0, value.length);
    };
    MP4Parser.read_BE_Unsigned_Integer = function (value) {
        return Token.readUIntBE(value, 0, value.length);
    };
    MP4Parser.prototype.parse = function () {
        var _this = this;
        this.metadata.setFormat('dataformat', 'MPEG-4 audio');
        var rootAtom = new Atom_1.Atom({ name: 'mp4', length: this.tokenizer.fileSize }, false, null);
        return rootAtom.readAtoms(this.tokenizer, function (atom) {
            if (atom.parent) {
                switch (atom.parent.header.name) {
                    case 'ilst':
                    case '<id>':
                        return _this.parseMetadataItemData(atom).then(null);
                }
            }
            switch (atom.header.name) {
                case "ftyp":
                    return _this.parseAtom_ftyp(atom.dataLen).then(function (types) {
                        debug('ftyp: ' + types.join('/'));
                    });
                case 'mdhd': // Media header atom
                    return _this.parseAtom_mdhd(atom);
                case 'mvhd': // 'movie' => 'mvhd': movie header atom; child of Movie Atom
                    return _this.parseAtom_mvhd(atom);
            }
            return _this.tokenizer.readToken(new Token.IgnoreType(atom.dataLen))
                .then(function () {
                debug("Ignore atom data: path=%s, payload-len=%s", atom.atomPath, atom.dataLen);
            });
        }, this.tokenizer.fileSize);
    };
    MP4Parser.prototype.addTag = function (id, value) {
        this.metadata.addTag(tagFormat, id, value);
    };
    MP4Parser.prototype.addWarning = function (message) {
        debug('Warning:' + message);
        this.warnings.push(message);
    };
    /**
     * Parse data of Meta-item-list-atom (item of 'ilst' atom)
     * @param metaAtom
     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     */
    MP4Parser.prototype.parseMetadataItemData = function (metaAtom) {
        var _this = this;
        var tagKey = metaAtom.header.name;
        return metaAtom.readAtoms(this.tokenizer, function (child) {
            switch (child.header.name) {
                case "data": // value atom
                    return _this.parseValueAtom(tagKey, child);
                case "name": // name atom (optional)
                    return _this.tokenizer.readToken(new AtomToken.NameAtom(child.dataLen)).then(function (name) {
                        tagKey += ":" + name.name;
                    });
                case "mean": // name atom (optional)
                    return _this.tokenizer.readToken(new AtomToken.NameAtom(child.dataLen)).then(function (mean) {
                        // console.log("  %s[%s] = %s", tagKey, header.name, mean.name);
                        tagKey += ":" + mean.name;
                    });
                default:
                    return _this.tokenizer.readToken(new Token.BufferType(child.dataLen)).then(function (dataAtom) {
                        _this.addWarning("Unsupported meta-item: " + tagKey + "[" + child.header.name + "] => value=" + dataAtom.toString("hex") + " ascii=" + dataAtom.toString("ascii"));
                    });
            }
        }, metaAtom.dataLen);
    };
    MP4Parser.prototype.parseValueAtom = function (tagKey, metaAtom) {
        var _this = this;
        return this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len)).then(function (dataAtom) {
            if (dataAtom.type.set !== 0) {
                throw new Error("Unsupported type-set != 0: " + dataAtom.type.set);
            }
            // Use well-known-type table
            // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35
            switch (dataAtom.type.type) {
                case 0: // reserved: Reserved for use where no type needs to be indicated
                    switch (tagKey) {
                        case "trkn":
                        case "disk":
                            var num = Token.UINT8.get(dataAtom.value, 3);
                            var of = Token.UINT8.get(dataAtom.value, 5);
                            // console.log("  %s[data] = %s/%s", tagKey, num, of);
                            _this.addTag(tagKey, num + "/" + of);
                            break;
                        case "gnre":
                            var genreInt = Token.UINT8.get(dataAtom.value, 1);
                            var genreStr = ID3v1Parser_1.Genres[genreInt - 1];
                            // console.log("  %s[data] = %s", tagKey, genreStr);
                            _this.addTag(tagKey, genreStr);
                            break;
                        default:
                        // console.log("  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }",
                        // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));
                    }
                    break;
                case 1: // UTF-8: Without any count or NULL terminator
                case 18: // Unknown: Found in m4b in combination with a 'Â©gen' tag
                    _this.addTag(tagKey, dataAtom.value.toString("utf-8"));
                    break;
                case 13: // JPEG
                    if (_this.options.skipCovers)
                        break;
                    _this.addTag(tagKey, {
                        format: "image/jpeg",
                        data: Buffer.from(dataAtom.value)
                    });
                    break;
                case 14: // PNG
                    if (_this.options.skipCovers)
                        break;
                    _this.addTag(tagKey, {
                        format: "image/png",
                        data: Buffer.from(dataAtom.value)
                    });
                    break;
                case 21: // BE Signed Integer
                    _this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));
                    break;
                case 22: // BE Unsigned Integer
                    _this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));
                    break;
                case 65: // An 8-bit signed integer
                    _this.addTag(tagKey, dataAtom.value.readInt8(0));
                    break;
                case 66: // A big-endian 16-bit signed integer
                    _this.addTag(tagKey, dataAtom.value.readInt16BE(0));
                    break;
                case 67: // A big-endian 32-bit signed integer
                    _this.addTag(tagKey, dataAtom.value.readInt32BE(0));
                    break;
                default:
                    _this.addWarning("atom key=" + tagKey + ", has unknown well-known-type (data-type): " + dataAtom.type.type);
            }
        });
    };
    /**
     * Parse movie header (mvhd) atom
     * @param mvhd mvhd atom
     */
    MP4Parser.prototype.parseAtom_mvhd = function (mvhd) {
        var _this = this;
        return this.tokenizer.readToken(new AtomToken.MvhdAtom(mvhd.dataLen)).then(function (mvhd_data) {
            _this.parse_mxhd(mvhd_data);
        });
    };
    /**
     * Parse media header (mdhd) atom
     * @param mdhd mdhd atom
     */
    MP4Parser.prototype.parseAtom_mdhd = function (mdhd) {
        var _this = this;
        return this.tokenizer.readToken(new AtomToken.MdhdAtom(mdhd.dataLen))
            .then(function (mdhd_data) {
            _this.parse_mxhd(mdhd_data);
        });
    };
    MP4Parser.prototype.parse_mxhd = function (mxhd) {
        this.metadata.setFormat('sampleRate', mxhd.timeScale);
        this.metadata.setFormat('duration', mxhd.duration / mxhd.timeScale); // calculate duration in seconds
    };
    MP4Parser.prototype.parseAtom_ftyp = function (len) {
        var _this = this;
        return this.tokenizer.readToken(AtomToken.ftyp).then(function (ftype) {
            len -= AtomToken.ftyp.len;
            if (len > 0) {
                return _this.parseAtom_ftyp(len).then(function (types) {
                    var value = Util_1.default.stripNulls(ftype.type).trim();
                    if (value.length > 0) {
                        types.push(value);
                    }
                    return types;
                });
            }
            return [];
        });
    };
    return MP4Parser;
}(BasicParser_1.BasicParser));
exports.MP4Parser = MP4Parser;
