"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var strtok3 = require("strtok3");
var Token = require("token-types");
var Chunk = require("./Chunk");
var stream_1 = require("stream");
var ID3v2Parser_1 = require("../id3v2/ID3v2Parser");
var FourCC_1 = require("../common/FourCC");
var BasicParser_1 = require("../common/BasicParser");
/**
 * AIFF - Audio Interchange File Format
 *
 * Ref:
 *  http://www.onicos.com/staff/iz/formats/aiff.html
 *  http://muratnkonar.com/aiff/index.html
 */
var AIFFParser = /** @class */ (function (_super) {
    __extends(AIFFParser, _super);
    function AIFFParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AIFFParser.prototype.parse = function () {
        var _this = this;
        return this.tokenizer.readToken(Chunk.Header)
            .then(function (header) {
            if (header.chunkID !== 'FORM')
                throw new Error("Invalid Chunk-ID, expected 'FORM'"); // Not AIFF format
            return _this.tokenizer.readToken(FourCC_1.FourCcToken).then(function (type) {
                _this.metadata.setFormat('dataformat', type);
            }).then(function () {
                return _this.readChunk();
            });
        });
    };
    AIFFParser.prototype.readChunk = function () {
        var _this = this;
        return this.tokenizer.readToken(Chunk.Header)
            .then(function (header) {
            switch (header.chunkID) {
                case 'COMM': // The Common Chunk
                    return _this.tokenizer.readToken(new Chunk.Common(header))
                        .then(function (common) {
                        _this.metadata.setFormat('bitsPerSample', common.sampleSize);
                        _this.metadata.setFormat('bitsPerSample', common.sampleSize);
                        _this.metadata.setFormat('sampleRate', common.sampleRate);
                        _this.metadata.setFormat('numberOfChannels', common.numChannels);
                        _this.metadata.setFormat('numberOfSamples', common.numSampleFrames);
                        _this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);
                    });
                case 'ID3 ': // ID3-meta-data
                    return _this.tokenizer.readToken(new Token.BufferType(header.size))
                        .then(function (id3_data) {
                        var id3stream = new ID3Stream(id3_data);
                        return strtok3.fromStream(id3stream).then(function (rst) {
                            return ID3v2Parser_1.ID3v2Parser.getInstance().parse(_this.metadata, rst, _this.options);
                        });
                    });
                case 'SSND': // Sound Data Chunk
                default:
                    return _this.tokenizer.ignore(header.size);
            }
        }).then(function () { return _this.readChunk(); }).catch(function (err) {
            if (err.message !== strtok3.endOfFile) {
                throw err;
            }
        });
    };
    return AIFFParser;
}(BasicParser_1.BasicParser));
exports.AIFFParser = AIFFParser;
var ID3Stream = /** @class */ (function (_super) {
    __extends(ID3Stream, _super);
    function ID3Stream(buf) {
        var _this = _super.call(this) || this;
        _this.buf = buf;
        return _this;
    }
    ID3Stream.prototype._read = function () {
        this.push(this.buf);
        this.push(null); // push the EOF-signaling `null` chunk
    };
    return ID3Stream;
}(stream_1.Readable));
