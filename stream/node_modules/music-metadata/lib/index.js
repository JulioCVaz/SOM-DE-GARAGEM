'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var ParserFactory_1 = require("./ParserFactory");
var MusicMetadataParser = /** @class */ (function () {
    function MusicMetadataParser() {
    }
    MusicMetadataParser.joinArtists = function (artists) {
        if (artists.length > 2) {
            return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];
        }
        return artists.join(' & ');
    };
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<IAudioMetadata>}
     */
    MusicMetadataParser.prototype.parseFile = function (filePath, opts) {
        if (opts === void 0) { opts = {}; }
        return ParserFactory_1.ParserFactory.parseFile(filePath, opts);
    };
    /**
     * Extract metadata from the given audio file
     * @param stream Audio ReadableStream
     * @param mimeType Mime-Type of Stream
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<IAudioMetadata>}
     */
    MusicMetadataParser.prototype.parseStream = function (stream, mimeType, opts) {
        if (opts === void 0) { opts = {}; }
        return ParserFactory_1.ParserFactory.parseStream(stream, mimeType, opts);
    };
    return MusicMetadataParser;
}());
exports.MusicMetadataParser = MusicMetadataParser;
/**
 * Parse audio file
 * @param filePath Media file to read meta-data from
 * @param options Parsing options
 * @returns {Promise<IAudioMetadata>}
 */
function parseFile(filePath, options) {
    return new MusicMetadataParser().parseFile(filePath, options);
}
exports.parseFile = parseFile;
/**
 * Parse audio Stream
 * @param stream
 * @param mimeType
 * @param options Parsing options
 * @returns {Promise<IAudioMetadata>}
 */
function parseStream(stream, mimeType, opts) {
    return new MusicMetadataParser().parseStream(stream, mimeType, opts);
}
exports.parseStream = parseStream;
/**
 * Create a dictionary ordered by their tag id (key)
 * @param nativeTags list of tags
 * @returns tags indexed by id
 */
function orderTags(nativeTags) {
    var tags = {};
    for (var _i = 0, nativeTags_1 = nativeTags; _i < nativeTags_1.length; _i++) {
        var tag = nativeTags_1[_i];
        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);
    }
    return tags;
}
exports.orderTags = orderTags;
/**
 * Convert rating to 1-5 star rating
 * @param {number} rating Normalized rating [0..1] (common.rating[n].rating)
 * @returns {number} Number of stars: 1, 2, 3, 4 or 5 stars
 */
function ratingToStars(rating) {
    return rating === undefined ? 0 : 1 + Math.round(rating * 4);
}
exports.ratingToStars = ratingToStars;
