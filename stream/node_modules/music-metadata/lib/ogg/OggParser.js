'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Token = require("token-types");
var initDebug = require("debug");
var Util_1 = require("../common/Util");
var FourCC_1 = require("../common/FourCC");
var VorbisParser_1 = require("./vorbis/VorbisParser");
var OpusParser_1 = require("./opus/OpusParser");
var SpeexParser_1 = require("./speex/SpeexParser");
var BasicParser_1 = require("../common/BasicParser");
var debug = initDebug('music-metadata:parser:ogg');
var SegmentTable = /** @class */ (function () {
    function SegmentTable(header) {
        this.len = header.page_segments;
    }
    SegmentTable.sum = function (buf, off, len) {
        var s = 0;
        for (var i = off; i < off + len; ++i) {
            s += buf[i];
        }
        return s;
    };
    SegmentTable.prototype.get = function (buf, off) {
        return {
            totalPageSize: SegmentTable.sum(buf, off, this.len)
        };
    };
    return SegmentTable;
}());
exports.SegmentTable = SegmentTable;
/**
 * Parser for Ogg logical bitstream framing
 */
var OggParser = /** @class */ (function (_super) {
    __extends(OggParser, _super);
    function OggParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OggParser.getInstance = function () {
        return new OggParser();
    };
    /**
     * Parse page
     * @returns {Promise<void>}
     */
    OggParser.prototype.parse = function () {
        var _this = this;
        debug('pos=%s, parsePage()', this.tokenizer.position);
        return this.tokenizer.readToken(OggParser.Header).then(function (header) {
            if (header.capturePattern !== 'OggS') { // Capture pattern
                throw new Error('expected ogg header but was not found');
            }
            _this.header = header;
            _this.pageNumber = header.pageSequenceNo;
            debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);
            return _this.tokenizer.readToken(new SegmentTable(header)).then(function (segmentTable) {
                debug('totalPageSize=%s', segmentTable.totalPageSize);
                return _this.tokenizer.readToken(new Token.BufferType(segmentTable.totalPageSize)).then(function (pageData) {
                    debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
                    if (header.headerType.firstPage) {
                        var id = new Token.StringType(7, 'ascii').get(pageData, 0);
                        switch (id) {
                            case 'vorbis': // Ogg/Vorbis
                                debug('Set page consumer to Ogg/Vorbis ');
                                _this.pageConsumer = new VorbisParser_1.VorbisParser(_this.metadata, _this.options);
                                break;
                            case 'OpusHea': // Ogg/Opus
                                debug('Set page consumer to Ogg/Opus');
                                _this.pageConsumer = new OpusParser_1.OpusParser(_this.metadata, _this.options, _this.tokenizer);
                                break;
                            case 'Speex  ': // Ogg/Speex
                                debug('Set page consumer to Ogg/Speex');
                                _this.pageConsumer = new SpeexParser_1.SpeexParser(_this.metadata, _this.options, _this.tokenizer);
                                break;
                            default:
                                throw new Error('gg audio-codec not recognized (id=' + id + ')');
                        }
                    }
                    _this.metadata.setFormat('dataformat', 'Ogg/' + _this.pageConsumer.codecName);
                    _this.pageConsumer.parsePage(header, pageData);
                    if (!header.headerType.lastPage) {
                        return _this.parse(); // Parse next page
                    }
                });
            });
        })
            .catch(function (err) {
            switch (err.message) {
                case 'End-Of-File':
                    break; // ignore this error
                case 'FourCC contains invalid characters':
                    if (_this.pageNumber > 0) {
                        // ignore this error: work-around if last OGG-page is not marked with last-page flag
                        // ToDo: capture warning
                        return _this.pageConsumer.flush();
                    }
                    throw err;
                default:
                    throw err;
            }
        });
    };
    OggParser.Header = {
        len: 27,
        get: function (buf, off) {
            return {
                capturePattern: FourCC_1.FourCcToken.get(buf, off),
                version: buf.readUInt8(off + 4),
                headerType: {
                    continued: Util_1.default.strtokBITSET.get(buf, off + 5, 0),
                    firstPage: Util_1.default.strtokBITSET.get(buf, off + 5, 1),
                    lastPage: Util_1.default.strtokBITSET.get(buf, off + 5, 2)
                },
                // packet_flag: buf.readUInt8(off + 5),
                absoluteGranulePosition: buf.readIntLE(off + 6, 6),
                streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),
                pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),
                pageChecksum: Token.UINT32_LE.get(buf, off + 22),
                page_segments: buf.readUInt8(off + 26)
            };
        }
    };
    return OggParser;
}(BasicParser_1.BasicParser));
exports.OggParser = OggParser;
