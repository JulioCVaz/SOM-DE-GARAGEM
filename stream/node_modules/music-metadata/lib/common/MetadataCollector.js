"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../index");
var _debug = require("debug");
var GenericTagTypes_1 = require("./GenericTagTypes");
var CombinedTagMapper_1 = require("./CombinedTagMapper");
var GenericTagMapper_1 = require("./GenericTagMapper");
var debug = _debug("music-metadata:collector");
var TagPriority = ['APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes MP4', 'ID3v1'];
/**
 * Provided to the parser to uodate the metadata result.
 * Responsible for triggering async updates
 */
var MetadataCollector = /** @class */ (function () {
    function MetadataCollector(opts) {
        this.opts = opts;
        this.format = {
            tagTypes: []
        };
        this.native = {};
        this.common = {
            track: { no: null, of: null },
            disk: { no: null, of: null }
        };
        /**
         * Keeps track of origin priority for each mapped id
         */
        this.commonOrigin = {};
        /**
         * Maps a tag type to a priority
         */
        this.originPriority = {};
        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
        var priority = 1;
        for (var _i = 0, TagPriority_1 = TagPriority; _i < TagPriority_1.length; _i++) {
            var tagType = TagPriority_1[_i];
            this.originPriority[tagType] = priority++;
        }
        this.originPriority.artificial = 500; // Filled using alternative tags
        this.originPriority.id3v1 = 600; // Consider worst due to field length limit
    }
    /**
     * @returns {boolean} true if one or more tags have been found
     */
    MetadataCollector.prototype.hasAny = function () {
        for (var tagType in this.native) {
            return true;
        }
        return false;
    };
    MetadataCollector.prototype.setFormat = function (key, value) {
        debug("format: " + key + " = " + value);
        this.format[key] = value; // as any to override readonly
        if (this.opts.observer) {
            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value: value } });
        }
    };
    MetadataCollector.prototype.addTag = function (tagType, tagId, value) {
        debug("tag " + tagType + "." + tagId + " = " + value);
        if (!this.native[tagType]) {
            this.format.tagTypes.push(tagType);
            this.native[tagType] = [];
        }
        this.native[tagType].push({ id: tagId, value: value });
        this.toCommon(tagType, tagId, value);
    };
    MetadataCollector.prototype.getNativeMetadata = function () {
        return {
            format: this.format,
            native: this.native
        };
    };
    MetadataCollector.prototype.postMap = function (tagType, tag) {
        // Common tag (alias) found
        // check if we need to do something special with common tag
        // if the event has been aliased then we need to clean it before
        // it is emitted to the user. e.g. genre (20) -> Electronic
        switch (tag.id) {
            case 'artist':
                if (this.commonOrigin.artist === this.originPriority[tagType]) {
                    // Assume the artist field is used as artists
                    return this.postMap('artificial', { id: 'artists', value: tag.value });
                }
                if (!this.common.artists) {
                    // Fill artists using artist source
                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });
                }
                break;
            case 'artists':
                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
                        // Fill artist using artists source
                        var artists = (this.common.artists || []).concat([tag.value]);
                        var value = index_1.MusicMetadataParser.joinArtists(artists);
                        var artistTag = { id: 'artist', value: value };
                        this.setGenericTag('artificial', artistTag);
                    }
                }
                break;
            case 'genre':
                tag.value = GenericTagMapper_1.CommonTagMapper.parseGenre(tag.value);
                break;
            case 'picture':
                tag.value.format = GenericTagMapper_1.CommonTagMapper.fixPictureMimeType(tag.value.format);
                break;
            case 'totaltracks':
                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
                return;
            case 'totaldiscs':
                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
                return;
            case 'track':
            case 'disk':
                var of = this.common[tag.id].of; // store of value, maybe maybe overwritten
                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);
                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
                return;
            case 'year':
            case 'originalyear':
                tag.value = parseInt(tag.value, 10);
                break;
            case 'date':
                // ToDo: be more strict on 'YYYY...'
                var year = parseInt(tag.value.substr(0, 4), 10);
                if (year && !isNaN(year)) {
                    this.common.year = year;
                }
                break;
            case 'discogs_label_id':
            case 'discogs_release_id':
            case 'discogs_master_release_id':
            case 'discogs_artist_id':
            case 'discogs_votes':
                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;
                break;
            case 'replaygain_track_peak':
                tag.value = typeof tag.value === 'string' ? parseFloat(tag.value) : tag.value;
                break;
            case 'gapless': // iTunes gap-less flag
                tag.value = tag.value === "1"; // boolean
                break;
            default:
            // nothing to do
        }
        this.setGenericTag(tagType, tag);
    };
    /**
     * Convert native tags to common tags
     * @returns {IAudioMetadata} Native + common tags
     */
    MetadataCollector.prototype.toCommonMetadata = function () {
        return {
            format: this.format,
            native: this.opts.native ? this.native : undefined,
            common: this.common
        };
    };
    /**
     * Convert native tag to common tags
     */
    MetadataCollector.prototype.toCommon = function (tagType, tagId, value) {
        var tag = { id: tagId, value: value };
        var genericTag = this.tagMapper.mapTag(tagType, tag);
        if (genericTag) {
            this.postMap(tagType, genericTag);
        }
    };
    /**
     * Set generic tag
     * @param {GenericTagId} tagId
     * @param {TagType} tagType originating header type, used to prioritize concurrent mappings
     * @param value
     */
    MetadataCollector.prototype.setGenericTag = function (tagType, tag) {
        debug("common." + tag.id + " = " + tag.value);
        var prio0 = this.commonOrigin[tag.id] || 1000;
        var prio1 = this.originPriority[tagType];
        if (GenericTagTypes_1.isSingleton(tag.id)) {
            if (prio1 <= prio0) {
                this.common[tag.id] = tag.value;
                this.commonOrigin[tag.id] = prio1;
            }
            else {
                return debug("Ignore native tag (singleton): " + tagType + "." + tag.id + " = " + tag.value);
            }
        }
        else {
            if (prio1 === prio0) {
                if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
                    this.common[tag.id].push(tag.value);
                }
                else {
                    debug("Ignore duplicate value: " + tagType + "." + tag.id + " = " + tag.value);
                }
                // no effect? this.commonOrigin[tag.id] = prio1;
            }
            else if (prio1 < prio0) {
                this.common[tag.id] = [tag.value];
                this.commonOrigin[tag.id] = prio1;
            }
            else {
                return debug("Ignore native tag (list): " + tagType + "." + tag.id + " = " + tag.value);
            }
        }
        if (this.opts.observer) {
            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });
        }
        // ToDo: trigger metadata event
    };
    return MetadataCollector;
}());
exports.MetadataCollector = MetadataCollector;
